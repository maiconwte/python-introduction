ğŸš€ Resumo OOP Python em 1 Linha:

"OOP em Python Ã© criar 'templates' inteligentes (classes) que geram objetos com dados (atributos) e comportamentos (mÃ©todos), organizados via heranÃ§a, encapsulamento e polimorfismo para cÃ³digo modular e reutilizÃ¡vel."

ğŸ“š ExplicaÃ§Ã£o Expandida dos 4 Pilares:

1. Classes e Objetos
python
class Carro:                    # Template/Planta (Classe)
    def __init__(self, marca):  # Construtor
        self.marca = marca      # Atributo/Estado

    def buzinar(self):          # MÃ©todo/Comportamento
        return "Biiiiip!"

meu_carro = Carro("Toyota")     # InstÃ¢ncia/Objeto concreto
print(meu_carro.buzinar())      # Biiiiip!

2. Encapsulamento
python
class ContaBancaria:
    def __init__(self):
        self.__saldo = 0        # Atributo privado (__)

    def depositar(self, valor): # Interface pÃºblica
        if valor > 0:
            self.__saldo += valor

    def get_saldo(self):        # Getter - acessa privado
        return self.__saldo

3. HeranÃ§a
python
class Animal:                   # Classe Pai
    def comer(self):
        print("Comendo...")

class Cachorro(Animal):         # Classe Filha
    def latir(self):
        print("Au Au!")

rex = Cachorro()
rex.comer()                     # Herdou do Animal
rex.latir()                     # MÃ©todo prÃ³prio

4. Polimorfismo
python
class Gato(Animal):
    def som(self):              # Mesmo nome, comportamento diferente
        return "Miau!"

class Vaca(Animal):
    def som(self):
        return "Mooo!"

animais = [Gato(), Vaca()]
for a in animais:
    print(a.som())              # Miau! / Mooo!

ğŸ¯ BenefÃ­cios da OOP:
Reuso (heranÃ§a)

OrganizaÃ§Ã£o (classes separam responsabilidades)

ManutenÃ§Ã£o (mudanÃ§as isoladas)

AbstraÃ§Ã£o (esconde complexidade)

Modularidade (componentes independentes)

ğŸ’¡ Em Python, tudo Ã© objeto - strings, listas, atÃ© funÃ§Ãµes!

ğŸ“š Resumos Individuais dos Conceitos de OOP
ğŸ—ï¸ Classe
"Modelo/planta que define a estrutura (atributos) e comportamentos (mÃ©todos) que os objetos terÃ£o, servindo como template para criaÃ§Ã£o de instÃ¢ncias."

python
class Pessoa:  # Classe = Molde/Receita
    especie = "Humano"  # Atributo de classe

    def __init__(self, nome):
        self.nome = nome  # Atributo de instÃ¢ncia

    def falar(self):  # MÃ©todo
        return f"OlÃ¡, sou {self.nome}"
ğŸ­ Objeto
"InstÃ¢ncia concreta criada a partir de uma classe, com seus prÃ³prios dados Ãºnicos, ocupando espaÃ§o em memÃ³ria e interagindo com o sistema."

python
p1 = Pessoa("JoÃ£o")  # Objeto = InstÃ¢ncia concreta
p2 = Pessoa("Maria")  # Outro objeto independente
# p1 e p2 sÃ£o objetos distintos com dados prÃ³prios
ğŸ“¦ Encapsulamento
"Mecanismo de proteÃ§Ã£o que esconde detalhes internos de implementaÃ§Ã£o, expondo apenas uma interface controlada atravÃ©s de atributos privados/protegidos."

python
class Conta:
    def __init__(self):
        self.__saldo = 0  # Atributo privado (encapsulado)

    def depositar(self, valor):  # Interface pÃºblica
        if valor > 0:  # ValidaÃ§Ã£o protegida
            self.__saldo += valor

    def ver_saldo(self):  # Acesso controlado
        return self.__saldo
ğŸ‘¨â€ğŸ‘¦ HeranÃ§a
"RelaÃ§Ã£o 'Ã©-um' que permite criar classes filhas baseadas em classes pais, herdando seus atributos e mÃ©todos enquanto pode estender ou modificar comportamentos."

python
class Veiculo:  # Classe Pai/Base
    def mover(self):
        print("Movendo...")

class Carro(Veiculo):  # Classe Filha/Derivada
    def buzinar(self):  # ExtensÃ£o
        print("Bibi!")

# Carro Ã‰-UM Veiculo + comportamentos extras
ğŸ­ Polimorfismo
"Capacidade de objetos de diferentes classes responderem Ã  mesma mensagem (mÃ©todo) de formas distintas, permitindo interfaces uniformes com comportamentos especÃ­ficos."

python
class Forma:
    def area(self):  # Interface comum
        pass

class Quadrado(Forma):
    def area(self):  # ImplementaÃ§Ã£o especÃ­fica
        return lado * lado

class Circulo(Forma):
    def area(self):  # Outra implementaÃ§Ã£o
        return 3.14 * raio ** 2

# Diferentes formas, mesmo mÃ©todo 'area()'
ğŸ¯ AbstraÃ§Ã£o
"Processo de identificar caracterÃ­sticas essenciais de um objeto, ignorando detalhes irrelevantes, criando modelos simplificados que representam a realidade."

python
from abc import ABC, abstractmethod

class Pagamento(ABC):  # Classe abstrata
    @abstractmethod
    def processar(self, valor):  # MÃ©todo abstrato
        pass  # Define O QUE fazer, nÃ£o COMO

class CartaoCredito(Pagamento):
    def processar(self, valor):  # ImplementaÃ§Ã£o concreta
        print(f"Processando R${valor} no cartÃ£o")
ğŸ”— AssociaÃ§Ã£o
"RelaÃ§Ã£o 'tem-um' entre objetos onde um objeto usa outro sem possuÃ­-lo permanentemente, mantendo independÃªncia entre as classes."

python
class Professor:
    def __init__(self, nome):
        self.nome = nome

class Curso:
    def __init__(self, nome, professor):  # AssociaÃ§Ã£o
        self.nome = nome
        self.professor = professor  # Curso TEM-UM Professor

prof = Professor("Carlos")
matematica = Curso("MatemÃ¡tica", prof)  # AssociaÃ§Ã£o criada
ğŸ¤ AgregaÃ§Ã£o
"RelaÃ§Ã£o 'tem-um' especial onde objetos podem existir independentemente, sendo um contÃªiner que agrega outros objetos sem responsabilidade sobre seu ciclo de vida."

python
class Departamento:
    def __init__(self, nome):
        self.nome = nome
        self.professores = []  # AgregaÃ§Ã£o: lista de objetos independentes

    def add_professor(self, professor):
        self.professores.append(professor)  # Agrega, nÃ£o cria

# Professor existe sem departamento
prof1 = Professor("Ana")
depto = Departamento("TI")
depto.add_professor(prof1)  # AgregaÃ§Ã£o
ğŸ’ ComposiÃ§Ã£o
"RelaÃ§Ã£o 'parte-de' forte onde um objeto Ã© composto por outros que nÃ£o podem existir independentemente, sendo criados e destruÃ­dos junto com o objeto principal."

python
class Motor:
    def __init__(self, tipo):
        self.tipo = tipo

class Carro:
    def __init__(self):
        self.motor = Motor("V8")  # ComposiÃ§Ã£o: criado com o carro

    def __del__(self):
        print("Carro e motor destruÃ­dos")  # Morrem juntos

# Motor nÃ£o existe sem o Carro
ğŸ§© Mensagem
"ComunicaÃ§Ã£o entre objetos onde um objeto solicita a execuÃ§Ã£o de um mÃ©todo de outro objeto, passando parÃ¢metros e recebendo respostas."

python
class ControleRemoto:
    def ligar(self, tv):  # Envia mensagem 'ligar' Ã  TV
        tv.ligar()  # Mensagem = Chamada de mÃ©todo

class TV:
    def ligar(self):  # Recebe e processa mensagem
        print("TV ligada")

controle = ControleRemoto()
tv = TV()
controle.ligar(tv)  # Envio de mensagem
âš™ï¸ Construtor
"MÃ©todo especial __init__ chamado automaticamente na criaÃ§Ã£o de um objeto, responsÃ¡vel por inicializar atributos e preparar o objeto para uso."

python
class Produto:
    def __init__(self, nome, preco):  # Construtor
        self.nome = nome  # Inicializa atributos
        self.preco = preco
        self.ativo = True  # Valores padrÃ£o

p = Produto("Notebook", 3500)  # __init__ Ã© chamado aqui
ğŸ§¹ Destrutor
"MÃ©todo especial __del__ chamado automaticamente antes da destruiÃ§Ã£o de um objeto, usado para liberar recursos como arquivos ou conexÃµes."

python
class Arquivo:
    def __init__(self, nome):
        self.arquivo = open(nome, 'w')

    def escrever(self, texto):
        self.arquivo.write(texto)

    def __del__(self):  # Destrutor
        self.arquivo.close()  # Libera recurso
        print("Arquivo fechado")

# __del__ Ã© chamado quando o objeto Ã© destruÃ­do
ğŸ”„ MÃ©todo
"FunÃ§Ã£o definida dentro de uma classe que descreve comportamentos dos objetos, operando sobre seus dados atravÃ©s do parÃ¢metro self."

python
class Calculadora:
    def somar(self, a, b):  # MÃ©todo
        return a + b  # Comportamento

    def subtrair(self, a, b):  # Outro mÃ©todo
        return a - b

calc = Calculadora()
calc.somar(5, 3)  # Chamada de mÃ©todo
ğŸ·ï¸ Atributo
"VariÃ¡vel associada a um objeto que armazena seu estado ou dados, podendo ser de instÃ¢ncia (Ãºnicos por objeto) ou de classe (compartilhados)."

python
class Pessoa:
    especie = "Humano"  # Atributo de classe (compartilhado)

    def __init__(self, nome):
        self.nome = nome  # Atributo de instÃ¢ncia (Ãºnico)
        self.idade = None  # Atributo inicializado como None

p1 = Pessoa("Ana")
p1.idade = 25  # AtribuiÃ§Ã£o de valor
ğŸ­ InstÃ¢ncia
"Objeto especÃ­fico criado a partir de uma classe, com sua prÃ³pria identidade, estado e espaÃ§o em memÃ³ria, representando uma ocorrÃªncia concreta."

python
class Retangulo:
    def __init__(self, largura, altura):
        self.largura = largura
        self.altura = altura

# Duas instÃ¢ncias diferentes
ret1 = Retangulo(10, 5)  # InstÃ¢ncia 1
ret2 = Retangulo(7, 3)   # InstÃ¢ncia 2

# ret1 e ret2 sÃ£o instÃ¢ncias independentes
ğŸ”§ Interface
"Contrato que define quais mÃ©todos uma classe deve implementar, sem especificar como, permitindo polimorfismo entre classes nÃ£o relacionadas por heranÃ§a."

python
class Imprimivel:  # Interface informal (Python usa duck typing)
    def imprimir(self):
        pass

class Relatorio(Imprimivel):
    def imprimir(self):
        print("Imprimindo relatÃ³rio...")

class Fatura(Imprimivel):
    def imprimir(self):
        print("Imprimindo fatura...")

# Ambas implementam a 'interface' Imprimivel
ğŸ§¬ Sobrescrita
"RedefiniÃ§Ã£o em uma classe filha de um mÃ©todo herdado da classe pai, permitindo comportamento especÃ­fico enquanto mantÃ©m a mesma assinatura."

python
class Animal:
    def som(self):  # MÃ©todo na classe pai
        return "Som genÃ©rico"

class Gato(Animal):
    def som(self):  # Sobrescrita do mÃ©todo
        return "Miau!"  # Comportamento especÃ­fico

animal = Animal()
print(animal.som())  # "Som genÃ©rico"
gato = Gato()
print(gato.som())    # "Miau!" (sobrescrito)
ğŸ§ª Sobrecarga
"Em Python, capacidade simulada de ter mÃºltiplos mÃ©todos com mesmo nome mas diferentes parÃ¢metros, usando valores padrÃ£o ou *args."

python
class Calculadora:
    def somar(self, a, b, c=0):  # Sobrecarga simulada
        return a + b + c

calc = Calculadora()
calc.somar(1, 2)     # Usa c=0
calc.somar(1, 2, 3)  # Usa c=3

# Python nÃ£o tem sobrecarga real como Java/C++
ğŸ“ Resumo Visual da Hierarquia:
text
OOP
â”œâ”€â”€ Classes (Modelos)
â”œâ”€â”€ Objetos (InstÃ¢ncias)
â”œâ”€â”€ 4 Pilares:
â”‚   â”œâ”€â”€ Encapsulamento (ProteÃ§Ã£o)
â”‚   â”œâ”€â”€ HeranÃ§a (Reuso)
â”‚   â”œâ”€â”€ Polimorfismo (Flexibilidade)
â”‚   â””â”€â”€ AbstraÃ§Ã£o (SimplificaÃ§Ã£o)
â”œâ”€â”€ RelaÃ§Ãµes:
â”‚   â”œâ”€â”€ AssociaÃ§Ã£o (Usa)
â”‚   â”œâ”€â”€ AgregaÃ§Ã£o (Tem, independente)
â”‚   â””â”€â”€ ComposiÃ§Ã£o (Parte-de, dependente)
â””â”€â”€ Mecanismos:
    â”œâ”€â”€ Mensagens (ComunicaÃ§Ã£o)
    â”œâ”€â”€ Construtor/Destrutor (Ciclo de vida)
    â””â”€â”€ MÃ©todos/Atributos (Comportamento/Estado)
Cada conceito trabalha em conjunto para criar sistemas modulares, reutilizÃ¡veis e de fÃ¡cil manutenÃ§Ã£o! ğŸš€