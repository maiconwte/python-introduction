Heran√ßa M√∫ltipla em Python - Exemplos Pr√°ticos
üìå Conceito B√°sico:
Uma classe que herda de duas ou mais classes pai simultaneamente.

python
class ClasseFilha(ClassePai1, ClassePai2, ClassePai3):
    pass

1. üéì Exemplo: Estudante Trabalhador
python
class Pessoa:
    def __init__(self, nome, idade):
        self.nome = nome
        self.idade = idade

    def apresentar(self):
        return f"Sou {self.nome}, tenho {self.idade} anos"

class Estudante:
    def __init__(self, matricula):
        self.matricula = matricula
        self.notas = []

    def estudar(self):
        return f"{self.nome} est√° estudando..."

    def adicionar_nota(self, nota):
        self.notas.append(nota)

    def calcular_media(self):
        return sum(self.notas) / len(self.notas) if self.notas else 0

class Funcionario:
    def __init__(self, salario, cargo):
        self.salario = salario
        self.cargo = cargo

    def trabalhar(self):
        return f"{self.nome} est√° trabalhando como {self.cargo}"

    def aumentar_salario(self, percentual):
        self.salario *= (1 + percentual/100)
        return self.salario

# Heran√ßa M√∫ltipla
class Estagiario(Pessoa, Estudante, Funcionario):
    def __init__(self, nome, idade, matricula, salario, cargo, empresa):
        # Inicializar cada classe pai explicitamente
        Pessoa.__init__(self, nome, idade)
        Estudante.__init__(self, matricula)
        Funcionario.__init__(self, salario, cargo)
        self.empresa = empresa  # Atributo pr√≥prio

    def mostrar_info(self):
        info = f"""
        ESTAGI√ÅRIO:
        Nome: {self.nome}
        Idade: {self.idade}
        Matr√≠cula: {self.matricula}
        Cargo: {self.cargo} na {self.empresa}
        Sal√°rio: R$ {self.salario:.2f}
        M√©dia das notas: {self.calcular_media():.1f}
        """
        return info

# Uso
joao = Estagiario("Jo√£o Silva", 22, "2023001", 1500, "Dev Jr", "Tech Solutions")
joao.adicionar_nota(8.5)
joao.adicionar_nota(9.0)
joao.aumentar_salario(10)

print(joao.mostrar_info())
print(joao.estudar())
print(joao.trabalhar())
print(joao.apresentar())
2. üéÆ Exemplo: Sistema de Jogo
python
class Movivel:
    def __init__(self, velocidade):
        self.velocidade = velocidade
        self.posicao = [0, 0]

    def mover(self, direcao):
        if direcao == "cima":
            self.posicao[1] += self.velocidade
        elif direcao == "baixo":
            self.posicao[1] -= self.velocidade
        elif direcao == "direita":
            self.posicao[0] += self.velocidade
        elif direcao == "esquerda":
            self.posicao[0] -= self.velocidade
        return f"Movendo para {direcao}. Nova posi√ß√£o: {self.posicao}"

class Atacante:
    def __init__(self, dano):
        self.dano = dano
        self.alvos = []

    def atacar(self, alvo):
        self.alvos.append(alvo)
        return f"Causou {self.dano} de dano em {alvo}"

    def poder_especial(self):
        return f"Ataque especial com {self.dano * 2} de dano!"

class Defensor:
    def __init__(self, defesa):
        self.defesa = defesa
        self.vida = 100

    def defender(self, dano_recebido):
        dano_real = max(0, dano_recebido - self.defesa)
        self.vida -= dano_real
        return f"Defendeu {self.defesa}. Vida restante: {self.vida}"

    def curar(self, quantidade):
        self.vida = min(100, self.vida + quantidade)
        return f"Curou {quantidade}. Vida: {self.vida}"

# Heran√ßa M√∫ltipla - Personagem Completo
class Guerreiro(Movivel, Atacante, Defensor):
    def __init__(self, nome, velocidade, dano, defesa):
        # Inicializar todas as classes pai
        Movivel.__init__(self, velocidade)
        Atacante.__init__(self, dano)
        Defensor.__init__(self, defesa)
        self.nome = nome
        self.experiencia = 0

    def ganhar_exp(self, exp):
        self.experiencia += exp
        if self.experiencia >= 100:
            self.evoluir()

    def evoluir(self):
        self.velocidade += 1
        self.dano += 5
        self.defesa += 3
        self.experiencia = 0
        return f"{self.nome} evoluiu! Status melhorados."

# Uso
arthur = Guerreiro("Arthur", velocidade=5, dano=15, defesa=10)

print(f"Guerreiro: {arthur.nome}")
print(arthur.mover("cima"))
print(arthur.atacar("Orc"))
print(arthur.defender(25))
print(arthur.curar(20))
print(arthur.poder_especial())
print(arthur.ganhar_exp(120))
3. üì± Exemplo: Dispositivo Eletr√¥nico
python
class Ligavel:
    def __init__(self):
        self.ligado = False

    def ligar(self):
        if not self.ligado:
            self.ligado = True
            return "Dispositivo ligado"
        return "J√° est√° ligado"

    def desligar(self):
        if self.ligado:
            self.ligado = False
            return "Dispositivo desligado"
        return "J√° est√° desligado"

class Conectavel:
    def __init__(self):
        self.conectado = False
        self.conexoes = []

    def conectar(self, dispositivo):
        if not self.conectado:
            self.conectado = True
            self.conexoes.append(dispositivo)
            return f"Conectado a {dispositivo}"
        return f"J√° conectado. Conex√µes: {self.conexoes}"

    def desconectar(self):
        if self.conectado:
            self.conectado = False
            desconectado = self.conexoes.pop()
            return f"Desconectado de {desconectado}"
        return "N√£o h√° conex√µes"

class Carregavel:
    def __init__(self, capacidade_bateria):
        self.capacidade_bateria = capacidade_bateria
        self.bateria = capacidade_bateria

    def carregar(self, quantidade):
        self.bateria = min(self.capacidade_bateria, self.bateria + quantidade)
        return f"Bateria: {self.bateria}/{self.capacidade_bateria}"

    def usar_bateria(self, quantidade):
        if self.bateria >= quantidade:
            self.bateria -= quantidade
            return f"Bateria restante: {self.bateria}"
        return "Bateria insuficiente"

# Heran√ßa M√∫ltipla
class Smartphone(Ligavel, Conectavel, Carregavel):
    def __init__(self, marca, modelo, capacidade_bateria):
        Ligavel.__init__(self)
        Conectavel.__init__(self)
        Carregavel.__init__(self, capacidade_bateria)
        self.marca = marca
        self.modelo = modelo
        self.aplicativos = []

    def instalar_app(self, app):
        self.aplicativos.append(app)
        return f"App {app} instalado"

    def fazer_chamada(self, numero):
        if self.ligado and self.bateria >= 5:
            self.usar_bateria(5)
            return f"Chamando {numero}..."
        return "N√£o √© poss√≠vel fazer chamada"

    def status(self):
        return f"""
        {self.marca} {self.modelo}
        Status: {'Ligado' if self.ligado else 'Desligado'}
        Bateria: {self.bateria}/{self.capacidade_bateria}
        Conex√µes: {len(self.conexoes)}
        Apps: {len(self.aplicativos)}
        """

# Uso
meu_celular = Smartphone("TechPhone", "X10", 3000)

print(meu_celular.ligar())
print(meu_celular.conectar("Wi-Fi Casa"))
print(meu_celular.carregar(1000))
print(meu_celular.instalar_app("WhatsApp"))
print(meu_celular.fazer_chamada("(11) 99999-9999"))
print(meu_celular.status())
4. üè¢ Exemplo: Sistema Empresarial
python
class FuncionarioCLT:
    def __init__(self, salario_base):
        self.salario_base = salario_base
        self.ferias_vencidas = 30

    def calcular_salario(self):
        # CLT: sal√°rio base + benef√≠cios
        return self.salario_base + 1000  # VT + VR

    def tirar_ferias(self, dias):
        if dias <= self.ferias_vencidas:
            self.ferias_vencidas -= dias
            return f"F√©rias de {dias} dias autorizadas"
        return f"Dias insuficientes. Dispon√≠vel: {self.ferias_vencidas} dias"

class FuncionarioPJ:
    def __init__(self, valor_hora):
        self.valor_hora = valor_hora
        self.horas_trabalhadas = 0

    def calcular_salario(self):
        # PJ: horas √ó valor hora
        return self.horas_trabalhadas * self.valor_hora

    def registrar_horas(self, horas):
        self.horas_trabalhadas += horas
        return f"{horas} horas registradas. Total: {self.horas_trabalhadas}h"

class Gerente:
    def __init__(self, bonus_gerencia):
        self.bonus_gerencia = bonus_gerencia
        self.equipe = []

    def gerenciar_equipe(self):
        return f"Gerenciando equipe de {len(self.equipe)} pessoas"

    def adicionar_membro(self, membro):
        self.equipe.append(membro)
        return f"{membro} adicionado √† equipe"

# MRO (Method Resolution Order) importante aqui!
class GerenteProjeto(FuncionarioCLT, Gerente, FuncionarioPJ):
    def __init__(self, nome, salario_base, bonus_gerencia, valor_hora):
        # Note: FuncionarioPJ n√£o √© chamado porque CLT vem primeiro
        # e tem prioridade na resolu√ß√£o de m√©todos
        FuncionarioCLT.__init__(self, salario_base)
        Gerente.__init__(self, bonus_gerencia)
        # FuncionarioPJ.__init__(self, valor_hora)  # Comentado por conflito

        self.nome = nome
        self.valor_hora = valor_hora
        self.projetos = []

    # Sobrescreve o m√©todo calcular_salario
    def calcular_salario(self):
        # Usa c√°lculo CLT + b√¥nus de gerente
        salario_clt = FuncionarioCLT.calcular_salario(self)
        return salario_clt + self.bonus_gerencia

    def adicionar_projeto(self, projeto):
        self.projetos.append(projeto)
        return f"Projeto {projeto} adicionado"

    def mostrar_mro(self):
        # Mostra a ordem de resolu√ß√£o de m√©todos
        return GerenteProjeto.__mro__

# Uso
gerente = GerenteProjeto("Carlos", 8000, 2000, 150)

print(f"Gerente: {gerente.nome}")
print(f"Sal√°rio: R$ {gerente.calcular_salario():.2f}")
print(gerente.adicionar_membro("Ana"))
print(gerente.adicionar_projeto("Sistema ERP"))
print(gerente.tirar_ferias(15))
print(gerente.gerenciar_equipe())

# MRO (Method Resolution Order)
print("\nOrdem de resolu√ß√£o de m√©todos (MRO):")
for classe in gerente.mostrar_mro():
    print(f"  ‚Üí {classe.__name__}")
5. ‚ö†Ô∏è Exemplo Proibido: Diamante (Diamond Problem)
python
class A:
    def metodo(self):
        return "M√©todo de A"

class B(A):
    def metodo(self):
        return "M√©todo de B"

class C(A):
    def metodo(self):
        return "M√©todo de C"

class D(B, C):  # Heran√ßa m√∫ltipla problem√°tica
    pass

# Testando
d = D()
print(d.metodo())  # Qual ser√° chamado? B ou C?
print(f"MRO de D: {[cls.__name__ for cls in D.__mro__]}")
"""
Sa√≠da:
M√©todo de B  (porque B vem antes de C na heran√ßa)
MRO de D: ['D', 'B', 'C', 'A', 'object']
"""

# Solu√ß√£o: Usar super() corretamente
class A2:
    def metodo(self):
        return "A2"

class B2(A2):
    def metodo(self):
        return f"B2 -> {super().metodo()}"

class C2(A2):
    def metodo(self):
        return f"C2 -> {super().metodo()}"

class D2(B2, C2):
    def metodo(self):
        return f"D2 -> {super().metodo()}"

d2 = D2()
print(f"\nCom super(): {d2.metodo()}")
print(f"MRO: {[cls.__name__ for cls in D2.__mro__]}")
üìä Resumo de Boas Pr√°ticas:
Quando Usar Heran√ßa M√∫ltipla:
Mixins (pequenas funcionalidades reutiliz√°veis)

Interfaces m√∫ltiplas

Heran√ßa de implementa√ß√µes distintas

Quando EVITAR:
Diamond problem (classe com dois pais que herdam do mesmo av√¥)

Hierarquias muito complexas

Quando composi√ß√£o √© melhor

Alternativa: Composi√ß√£o
python
# Em vez de heran√ßa m√∫ltipla, use composi√ß√£o
class Pessoa:
    def __init__(self, nome):
        self.nome = nome

class EstudanteComposicao:
    def __init__(self, pessoa, matricula):
        self.pessoa = pessoa  # Composi√ß√£o
        self.matricula = matricula

    @property
    def nome(self):
        return self.pessoa.nome

# Mais flex√≠vel e menos acoplado
p = Pessoa("Maria")
estudante = EstudanteComposicao(p, "2023001")
Mixins (Padr√£o Recomendado):
python
class JsonSerializableMixin:
    def to_json(self):
        import json
        return json.dumps(self.__dict__)

class LoggableMixin:
    def log(self, mensagem):
        print(f"[LOG] {mensagem}")

class Produto(JsonSerializableMixin, LoggableMixin):
    def __init__(self, nome, preco):
        self.nome = nome
        self.preco = preco

p = Produto("Notebook", 3500)
print(p.to_json())
p.log("Produto criado")

üîë Key Takeaways:
MRO (Method Resolution Order) determina qual m√©todo √© chamado

Use super() para chamar m√©todos dos pais corretamente

Prefira mixins para funcionalidades pequenas e reutiliz√°veis

Evite o diamond problem com hierarquias planas

Considere composi√ß√£o como alternativa √† heran√ßa m√∫ltipla complexa

A heran√ßa m√∫ltipla √© poderosa, mas requer cuidado no design! üéØ****