Decoradores em Python - Resumo
üéØ O que s√£o Decoradores?
"Fun√ß√µes que modificam/comportam outras fun√ß√µes, envolvendo-as com funcionalidades extras sem alterar seu c√≥digo original."

Analogia Simples:
python
# Decorador = Embrulho de presente
# Fun√ß√£o original = Presente
# Funcionalidade extra = Papel, fita, la√ßo
üìö 5 Exemplos B√°sicos
1. üïí Decorador de Timing (Medir Tempo de Execu√ß√£o)
python
import time

def medir_tempo(func):
    """Decorador que mede o tempo de execu√ß√£o de uma fun√ß√£o"""
    def wrapper(*args, **kwargs):
        inicio = time.time()
        resultado = func(*args, **kwargs)
        fim = time.time()
        print(f"‚è±Ô∏è  {func.__name__} executou em {fim - inicio:.4f} segundos")
        return resultado
    return wrapper

# Uso
@medir_tempo
def calcular_fatorial(n):
    """Calcula fatorial de n"""
    import math
    return math.factorial(n)

@medir_tempo
def dormir(segundos):
    """Simula uma opera√ß√£o demorada"""
    time.sleep(segundos)
    return f"Dormiu {segundos} segundos"

# Teste
print(calcular_fatorial(1000))  # Mostra tempo de execu√ß√£o
print(dormir(2))                # Mostra ~2 segundos
2. üîê Decorador de Cache/Memoriza√ß√£o
python
def cache(func):
    """Decorador que armazena resultados para evitar rec√°lculos"""
    memoria = {}

    def wrapper(*args):
        if args in memoria:
            print(f"‚ö° Cache hit para {func.__name__}{args}")
            return memoria[args]

        print(f"üîÑ Calculando {func.__name__}{args}")
        resultado = func(*args)
        memoria[args] = resultado
        return resultado

    return wrapper

@cache
def fibonacci(n):
    """Calcula o n-√©simo n√∫mero de Fibonacci"""
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

@cache
def fatorial(n):
    """Calcula fatorial de n"""
    if n == 0:
        return 1
    return n * fatorial(n-1)

# Teste
print("Fibonacci(10):", fibonacci(10))
print("Fibonacci(10) novamente:", fibonacci(10))  # Usa cache
print("Fatorial(5):", fatorial(5))
print("Fatorial(5) novamente:", fatorial(5))      # Usa cache
3. üõ°Ô∏è Decorador de Valida√ß√£o
python
def validar_numeros_positivos(func):
    """Decorador que valida se argumentos s√£o n√∫meros positivos"""
    def wrapper(*args, **kwargs):
        # Valida argumentos posicionais
        for i, arg in enumerate(args):
            if isinstance(arg, (int, float)) and arg < 0:
                raise ValueError(f"Argumento {i} deve ser positivo: {arg}")

        # Valida argumentos nomeados
        for chave, valor in kwargs.items():
            if isinstance(valor, (int, float)) and valor < 0:
                raise ValueError(f"'{chave}' deve ser positivo: {valor}")

        return func(*args, **kwargs)
    return wrapper

@validar_numeros_positivos
def calcular_area_retangulo(largura, altura):
    """Calcula √°rea de um ret√¢ngulo"""
    return largura * altura

@validar_numeros_positivos
def dividir_numeros(a, b):
    """Divide dois n√∫meros"""
    return a / b

# Teste
try:
    print("√Årea 5x3:", calcular_area_retangulo(5, 3))    # ‚úÖ Funciona
    print("√Årea -5x3:", calcular_area_retangulo(-5, 3))  # ‚ùå Erro
except ValueError as e:
    print(f"Erro: {e}")

try:
    print("Divis√£o 10/2:", dividir_numeros(a=10, b=2))    # ‚úÖ Funciona
    print("Divis√£o 10/-2:", dividir_numeros(10, b=-2))    # ‚ùå Erro
except ValueError as e:
    print(f"Erro: {e}")
4. üìù Decorador de Logging
python
def logger(func):
    """Decorador que registra execu√ß√µes de fun√ß√µes"""
    def wrapper(*args, **kwargs):
        print(f"üìù Chamando {func.__name__}...")
        print(f"   Args: {args}")
        print(f"   Kwargs: {kwargs}")

        try:
            resultado = func(*args, **kwargs)
            print(f"‚úÖ {func.__name__} retornou: {resultado}")
            return resultado
        except Exception as e:
            print(f"‚ùå {func.__name__} falhou: {e}")
            raise

    return wrapper

@logger
def somar(a, b):
    """Soma dois n√∫meros"""
    return a + b

@logger
def saudacao(nome, saudacao="Ol√°"):
    """Retorna sauda√ß√£o personalizada"""
    return f"{saudacao}, {nome}!"

# Teste
print(somar(5, 3))
print(saudacao("Maria"))
print(saudacao("Jo√£o", saudacao="Bom dia"))
5. üîÑ Decorador com Par√¢metros
python
def repetir(n_vezes=1):
    """Decorador que repete a execu√ß√£o de uma fun√ß√£o"""
    def decorador(func):
        def wrapper(*args, **kwargs):
            resultados = []
            for i in range(n_vezes):
                print(f"üîÑ Execu√ß√£o {i+1}/{n_vezes}")
                resultado = func(*args, **kwargs)
                resultados.append(resultado)
            return resultados[-1] if n_vezes == 1 else resultados
        return wrapper
    return decorador

# Uso com par√¢metro
@repetir(n_vezes=3)
def cumprimentar(nome):
    """Cumprimenta uma pessoa"""
    return f"Ol√°, {nome}!"

# Uso sem par√¢metro (usa padr√£o)
@repetir()  # equivalente a @repetir
def gerar_numero_aleatorio():
    """Gera n√∫mero aleat√≥rio"""
    import random
    return random.randint(1, 100)

# Decorador com valor padr√£o
@repetir(n_vezes=5)
def piscar_led():
    """Simula piscar de LED"""
    return "LED piscou!"

# Teste
print("Cumprimentar 3x:", cumprimentar("Ana"))
print("\nGerar n√∫mero (1x):", gerar_numero_aleatorio())
print("\nPiscar LED 5x:", piscar_led())
üîß Exemplo B√¥nus: Decorador de Classe
python
def adicionar_metodos(cls):
    """Decorador que adiciona m√©todos a uma classe"""
    cls.saudacao = lambda self: f"Ol√°, sou {self.__class__.__name__}"
    cls.contar = classmethod(lambda cls: f"Temos {cls.__name__}")
    return cls

@adicionar_metodos
class Pessoa:
    def __init__(self, nome):
        self.nome = nome

# Teste
p = Pessoa("Carlos")
print(p.saudacao())        # M√©todo adicionado pelo decorador
print(Pessoa.contar())     # M√©todo de classe adicionado
üìä Resumo Visual do Funcionamento:
Sintaxe com @:
python
@decorador
def minha_funcao():
    pass

# √â equivalente a:
def minha_funcao():
    pass
minha_funcao = decorador(minha_funcao)
Estrutura B√°sica de um Decorador:
python
def meu_decorador(func):           # 1. Recebe fun√ß√£o
    def wrapper(*args, **kwargs):  # 2. Cria wrapper
        # C√≥digo ANTES da fun√ß√£o   # 3. Faz algo antes
        resultado = func(*args, **kwargs)  # 4. Chama fun√ß√£o original
        # C√≥digo DEPOIS da fun√ß√£o  # 5. Faz algo depois
        return resultado
    return wrapper                 # 6. Retorna wrapper
üéØ Casos de Uso Comuns:
Logging/Auditoria - Registrar execu√ß√µes

Cache/Memoiza√ß√£o - Armazenar resultados

Valida√ß√£o - Verificar argumentos

Timing/Benchmark - Medir performance

Autentica√ß√£o - Verificar permiss√µes

Retry - Tentar novamente em falhas

Rate Limiting - Limitar chamadas

Depura√ß√£o - Debug mais f√°cil

üí° Dicas Importantes:
Preservar Metadados:
python
from functools import wraps

def decorador_preservado(func):
    @wraps(func)  # üî• Preserva nome, docstring, etc.
    def wrapper(*args, **kwargs):
        """Wrapper function"""
        return func(*args, **kwargs)
    return wrapper

@decorador_preservado
def exemplo():
    """Fun√ß√£o de exemplo"""
    pass

print(exemplo.__name__)   # 'exemplo' (n√£o 'wrapper')
print(exemplo.__doc__)    # 'Fun√ß√£o de exemplo'
Decoradores Aninhados:
python
@decorador1
@decorador2
@decorador3
def funcao():
    pass

# Equivale a:
# funcao = decorador1(decorador2(decorador3(funcao)))
Decoradores Built-in √öteis:
python
from functools import lru_cache

@lru_cache(maxsize=128)  # Cache com LRU (Least Recently Used)
def fibonacci(n):
    pass

from functools import wraps  # J√° vimos

import threading
from functools import wraps

def synchronized(lock):
    """Decorador para thread safety"""
    def decorador(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            with lock:
                return func(*args, **kwargs)
        return wrapper
    return decorador
Decoradores s√£o "a√ß√∫car sint√°tico" poderoso que tornam o Python mais expressivo! üç¨