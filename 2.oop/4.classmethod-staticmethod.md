@classmethod vs @staticmethod - Guia Completo
üìå Resumo R√°pido:
Caracter√≠stica	@classmethod	@staticmethod
1¬∫ Par√¢metro	cls (classe)	Nenhum especial
Acesso a	Atributos/m√©todos da CLASSE	Nenhum (isolado)
Pode modificar	Estado da classe	Nada
Heran√ßa	Funciona com heran√ßa	N√£o afetado
Uso comum	Factory methods, alternativos a __init__	Fun√ß√µes utilit√°rias
üîç Exemplos Detalhados
1. üìä Exemplo Pr√°tico: Sistema de Controle de Estoque
python
class Produto:
    # Atributo de CLASSE (compartilhado)
    taxa_imposto = 0.20  # 20%
    total_produtos = 0

    def __init__(self, nome, preco_custo):
        self.nome = nome
        self.preco_custo = preco_custo
        self.id = Produto.total_produtos + 1
        Produto.total_produtos += 1

    # ‚≠ê M√âTODO DE INST√ÇNCIA (padr√£o) - Recebe self
    def calcular_preco_venda(self, margem_lucro=0.30):
        """Calcula pre√ßo de venda baseado em custo + lucro + imposto"""
        lucro = self.preco_custo * margem_lucro
        imposto = self.preco_custo * Produto.taxa_imposto
        return self.preco_custo + lucro + imposto

    # ‚≠ê @classmethod - Recebe cls (refer√™ncia √† classe)
    @classmethod
    def criar_com_desconto(cls, nome, preco_original, desconto_percentual):
        """M√©todo de f√°brica: cria produto com desconto aplicado"""
        preco_com_desconto = preco_original * (1 - desconto_percentual/100)
        return cls(nome, preco_com_desconto)

    @classmethod
    def alterar_taxa_imposto(cls, nova_taxa):
        """Altera taxa de imposto para TODOS os produtos"""
        cls.taxa_imposto = nova_taxa
        return f"Taxa alterada para {nova_taxa*100}%"

    @classmethod
    def criar_a_partir_string(cls, string_produto):
        """Cria produto a partir de string formatada: 'nome;preco'"""
        nome, preco = string_produto.split(';')
        return cls(nome.strip(), float(preco.strip()))

    # ‚≠ê @staticmethod - N√£o recebe self nem cls
    @staticmethod
    def calcular_desconto(preco_original, percentual_desconto):
        """Calcula pre√ßo com desconto (fun√ß√£o utilit√°ria)"""
        return preco_original * (1 - percentual_desconto/100)

    @staticmethod
    def validar_preco(preco):
        """Valida se pre√ßo √© num√©rico e positivo"""
        return isinstance(preco, (int, float)) and preco > 0

    @staticmethod
    def formatar_moeda(valor):
        """Formata valor como moeda brasileira"""
        return f"R$ {valor:,.2f}".replace(',', 'X').replace('.', ',').replace('X', '.')

# Uso PR√ÅTICO
print("=" * 50)
print("SISTEMA DE CONTROLE DE ESTOQUE")
print("=" * 50)

# 1. Criando produtos normais (com __init__)
p1 = Produto("Notebook", 2500)
print(f"Produto 1: {p1.nome}")
print(f"Pre√ßo de venda: {Produto.formatar_moeda(p1.calcular_preco_venda())}")

# 2. Usando classmethod como factory method
p2 = Produto.criar_com_desconto("Tablet", 2000, 15)  # 15% de desconto
print(f"\nProduto 2 (com desconto): {p2.nome}")
print(f"Pre√ßo custo com desconto: {Produto.formatar_moeda(p2.preco_custo)}")
print(f"Pre√ßo de venda: {Produto.formatar_moeda(p2.calcular_preco_venda())}")

# 3. Alterando atributo da CLASSE (afeta todos)
print(f"\nTaxa de imposto atual: {Produto.taxa_imposto*100}%")
Produto.alterar_taxa_imposto(0.25)  # Muda para 25%
print(f"Taxa de imposto nova: {Produto.taxa_imposto*100}%")

# 4. Criando a partir de string (classmethod)
p3 = Produto.criar_a_partir_string("Smartphone; 1800")
print(f"\nProduto 3 (de string): {p3.nome}")
print(f"Pre√ßo de venda: {Produto.formatar_moeda(p3.calcular_preco_venda(0.25))}")

# 5. Usando staticmethods (fun√ß√µes utilit√°rias)
print(f"\nüìä FUN√á√ïES UTILIT√ÅRIAS (staticmethods):")
print(f"Desconto de 20% em R$100: {Produto.formatar_moeda(Produto.calcular_desconto(100, 20))}")
print(f"Pre√ßo 50 √© v√°lido? {Produto.validar_preco(50)}")
print(f"Pre√ßo -10 √© v√°lido? {Produto.validar_preco(-10)}")
print(f"Pre√ßo 'abc' √© v√°lido? {Produto.validar_preco('abc')}")

# 6. Acesso atrav√©s da inst√¢ncia tamb√©m funciona
print(f"\nüîÑ Acesso via inst√¢ncia:")
print(f"Via inst√¢ncia p1: {p1.formatar_moeda(99.99)}")
print(f"Via classe Produto: {Produto.formatar_moeda(99.99)}")

print(f"\nTotal de produtos criados: {Produto.total_produtos}")
2. üè¶ Exemplo: Sistema Banc√°rio com Heran√ßa
python
class ContaBancaria:
    taxa_juros_padrao = 0.05  # 5% ao ano
    total_contas = 0

    def __init__(self, titular, saldo_inicial=0):
        self.titular = titular
        self.saldo = saldo_inicial
        self.numero = ContaBancaria.total_contas + 1
        ContaBancaria.total_contas += 1

    def depositar(self, valor):
        self.saldo += valor
        return self.saldo

    # ‚≠ê classmethod que funciona com heran√ßa
    @classmethod
    def criar_conta_poupanca(cls, titular, saldo_inicial):
        """Factory method espec√≠fico para poupan√ßa"""
        conta = cls(titular, saldo_inicial)
        conta.tipo = "Poupan√ßa"
        return conta

    @classmethod
    def criar_conta_salario(cls, titular, empresa):
        """Factory method para conta sal√°rio"""
        conta = cls(titular, 0)
        conta.empresa = empresa
        conta.tipo = "Sal√°rio"
        return conta

    @classmethod
    def definir_taxa_juros(cls, nova_taxa):
        """Altera taxa de juros da classe"""
        cls.taxa_juros_padrao = nova_taxa

    # ‚≠ê staticmethod - √∫til para c√°lculos financeiros
    @staticmethod
    def calcular_juros_compostos(principal, taxa, anos):
        """Calcula juros compostos: P(1 + r)^t"""
        return principal * (1 + taxa) ** anos

    @staticmethod
    def converter_moeda(valor, taxa_cambio):
        """Converte entre moedas"""
        return valor * taxa_cambio

    @staticmethod
    def validar_cpf(cpf):
        """Valida CPF (implementa√ß√£o simplificada)"""
        import re
        cpf = re.sub(r'\D', '', cpf)
        return len(cpf) == 11

# Classe derivada
class ContaCorrente(ContaBancaria):
    limite_cheque_especial = 1000

    def __init__(self, titular, saldo_inicial=0):
        super().__init__(titular, saldo_inicial)
        self.tipo = "Corrente"

    # ‚≠ê classmethod SOBRESCRITO na classe filha
    @classmethod
    def criar_conta_especial(cls, titular, saldo_inicial, limite_extra):
        conta = cls(titular, saldo_inicial)
        conta.limite_cheque_especial = limite_extra
        return conta

# Demonstra√ß√£o com HERAN√áA
print("\n" + "=" * 50)
print("SISTEMA BANC√ÅRIO COM HERAN√áA")
print("=" * 50)

# 1. Usando classmethod da classe pai
conta_poupanca = ContaBancaria.criar_conta_poupanca("Maria", 1000)
print(f"Conta Poupan√ßa criada:")
print(f"  Titular: {conta_poupanca.titular}")
print(f"  Tipo: {conta_poupanca.tipo}")
print(f"  Saldo: R$ {conta_poupanca.saldo:.2f}")

# 2. Usando classmethod da classe filha
conta_especial = ContaCorrente.criar_conta_especial("Jo√£o", 500, 2000)
print(f"\nConta Especial criada:")
print(f"  Titular: {conta_especial.titular}")
print(f"  Tipo: {conta_especial.tipo}")
print(f"  Limite especial: R$ {conta_especial.limite_cheque_especial:.2f}")

# 3. Acesso a classmethod via classe filha
ContaCorrente.definir_taxa_juros(0.06)
print(f"\nTaxa de juros da ContaCorrente: {ContaCorrente.taxa_juros_padrao*100}%")
print(f"Taxa de juros da ContaBancaria: {ContaBancaria.taxa_juros_padrao*100}%")

# 4. Usando staticmethods (n√£o dependem da classe)
print(f"\nüìà C√ÅLCULOS FINANCEIROS (staticmethods):")
investimento = 1000
taxa = 0.1
anos = 5
resultado = ContaBancaria.calcular_juros_compostos(investimento, taxa, anos)
print(f"Investimento de R$ {investimento:.2f} a {taxa*100}% em {anos} anos:")
print(f"  Resultado: R$ {resultado:.2f}")

# 5. staticmethod acessado via classe filha
print(f"\nConvers√£o USD para BRL (1 USD = 5.0 BRL):")
print(f"  $100 = R$ {ContaCorrente.converter_moeda(100, 5.0):.2f}")

print(f"\nTotal de contas criadas: {ContaBancaria.total_contas}")
3. üéÆ Exemplo: Sistema de Jogo com Diferentes Personagens
python
class Personagem:
    vida_maxima = 100

    def __init__(self, nome):
        self.nome = nome
        self.vida = Personagem.vida_maxima
        self.nivel = 1

    def atacar(self):
        return f"{self.nome} ataca!"

    # ‚≠ê classmethod para criar personagens pr√©-configurados
    @classmethod
    def criar_guerreiro(cls, nome):
        personagem = cls(nome)
        personagem.forca = 10
        personagem.defesa = 8
        personagem.classe = "Guerreiro"
        return personagem

    @classmethod
    def criar_mago(cls, nome):
        personagem = cls(nome)
        personagem.inteligencia = 12
        personagem.mana = 50
        personagem.classe = "Mago"
        return personagem

    @classmethod
    def criar_arqueiro(cls, nome):
        personagem = cls(nome)
        personagem.destreza = 15
        personagem.alcance = 10
        personagem.classe = "Arqueiro"
        return personagem

    # ‚≠ê classmethod para configurar regras do jogo
    @classmethod
    def configurar_dificuldade(cls, dificuldade):
        if dificuldade == "facil":
            cls.vida_maxima = 150
        elif dificuldade == "normal":
            cls.vida_maxima = 100
        elif dificuldade == "dificil":
            cls.vida_maxima = 75

    # ‚≠ê staticmethod para c√°lculos de jogo
    @staticmethod
    def calcular_dano(base_dano, multiplicador_critico=2.0, chance_critico=0.1):
        """Calcula dano com chance de cr√≠tico"""
        import random
        if random.random() < chance_critico:
            return base_dano * multiplicador_critico
        return base_dano

    @staticmethod
    def rolar_dado(lados=20):
        """Rola um dado de N lados"""
        import random
        return random.randint(1, lados)

    @staticmethod
    def calcular_experiencia(nivel_inimigo, nivel_jogador):
        """Calcula experi√™ncia ganha baseado na diferen√ßa de n√≠veis"""
        diferenca = nivel_inimigo - nivel_jogador
        if diferenca >= 3:
            return 100  # Inimigo muito mais forte
        elif diferenca <= -3:
            return 10   # Inimigo muito mais fraco
        else:
            return 50   # N√≠veis similares

# Demonstra√ß√£o
print("\n" + "=" * 50)
print("SISTEMA DE JOGO")
print("=" * 50)

# 1. Criando personagens com classmethods
guerreiro = Personagem.criar_guerreiro("Thor")
mago = Personagem.criar_mago("Merlin")
arqueiro = Personagem.criar_arqueiro("Legolas")

print("Personagens criados:")
print(f"  {guerreiro.nome} - {guerreiro.classe} (For√ßa: {guerreiro.forca})")
print(f"  {mago.nome} - {mago.classe} (Intelig√™ncia: {mago.inteligencia})")
print(f"  {arqueiro.nome} - {arqueiro.classe} (Destreza: {arqueiro.destreza})")

# 2. Configurando jogo via classmethod
print(f"\nVida m√°xima padr√£o: {Personagem.vida_maxima}")
Personagem.configurar_dificuldade("dificil")
print(f"Vida m√°xima em 'dificil': {Personagem.vida_maxima}")

# 3. Usando staticmethods para mec√¢nicas de jogo
print(f"\nüé≤ MEC√ÇNICAS DE JOGO (staticmethods):")
print(f"Dado D20: {Personagem.rolar_dado(20)}")
print(f"Dado D6: {Personagem.rolar_dado(6)}")

print(f"\n‚öîÔ∏è C√ÅLCULO DE DANO:")
for i in range(5):
    dano = Personagem.calcular_dano(base_dano=50)
    critico = "‚ú® CR√çTICO!" if dano > 50 else ""
    print(f"  Ataque {i+1}: {dano:.0f} {critico}")

print(f"\nüìä EXPERI√äNCIA:")
print(f"  N√≠vel 5 vs N√≠vel 5: {Personagem.calcular_experiencia(5, 5)} XP")
print(f"  N√≠vel 5 vs N√≠vel 10: {Personagem.calcular_experiencia(10, 5)} XP")
print(f"  N√≠vel 10 vs N√≠vel 5: {Personagem.calcular_experiencia(5, 10)} XP")
4. üìä Tabela Comparativa Pr√°tica
python
class AnaliseComparativa:
    """Classe demonstrando diferen√ßas pr√°ticas"""

    atributo_classe = "Valor da Classe"

    def __init__(self, valor):
        self.valor_instancia = valor

    def metodo_instancia(self):
        """M√©todo normal: acessa self e cls"""
        return f"Inst√¢ncia: {self.valor_instancia}, Classe: {self.atributo_classe}"

    @classmethod
    def metodo_classe(cls, novo_valor):
        """classmethod: acessa cls, pode modificar estado da classe"""
        cls.atributo_classe = novo_valor
        return f"Classe modificada: {cls.atributo_classe}"

    @staticmethod
    def metodo_estatico(valor1, valor2):
        """staticmethod: fun√ß√£o independente"""
        return f"Soma: {valor1 + valor2}"

# Testando as diferen√ßas
print("=" * 50)
print("AN√ÅLISE COMPARATIVA")
print("=" * 50)

obj1 = AnaliseComparativa("Objeto 1")
obj2 = AnaliseComparativa("Objeto 2")

print("\n1. Acesso a m√©todo de inst√¢ncia:")
print(f"   obj1: {obj1.metodo_instancia()}")
print(f"   obj2: {obj2.metodo_instancia()}")

print("\n2. Usando classmethod (modifica CLASSE):")
print(f"   Via obj1: {obj1.metodo_classe('NOVO VALOR')}")
print(f"   Agora obj1: {obj1.metodo_instancia()}")
print(f"   obj2 tamb√©m mudou: {obj2.metodo_instancia()}")

print("\n3. Usando staticmethod (n√£o afeta nada):")
print(f"   Via classe: {AnaliseComparativa.metodo_estatico(5, 3)}")
print(f"   Via obj1: {obj1.metodo_estatico(10, 20)}")
print(f"   Via obj2: {obj2.metodo_estatico(100, 200)}")

print("\n4. Tentando acessar atributos:")
try:
    print(f"   staticmethod acessar self.valor_instancia? ‚ùå IMPOSS√çVEL")
except:
    print("   (N√£o tem acesso a self)")

try:
    print(f"   staticmethod acessar cls.atributo_classe? ‚ùå IMPOSS√çVEL")
except:
    print("   (N√£o tem acesso a cls)")
5. ‚ö†Ô∏è Casos Especiais e Armadilhas
python
class CasosEspeciais:
    contador = 0

    def __init__(self):
        CasosEspeciais.contador += 1

    # ‚≠ê classmethod que chama outro classmethod
    @classmethod
    def metodo_a(cls):
        return f"M√©todo A da {cls.__name__}"

    @classmethod
    def metodo_b(cls):
        # Chama outro classmethod da mesma classe
        return f"M√©todo B chama: {cls.metodo_a()}"

    # ‚≠ê classmethod que cria inst√¢ncias de subclasses corretamente
    @classmethod
    def criar_tipo(cls, tipo, *args):
        """Factory method que cria subclass baseada no tipo"""
        if tipo == "especial":
            return SubclasseEspecial(*args)
        else:
            return cls(*args)

class SubclasseEspecial(CasosEspeciais):
    @classmethod
    def metodo_a(cls):
        return f"M√©todo A ESPECIAL da {cls.__name__}"

    @staticmethod
    def metodo_estatico_sobrescrito():
        return "Staticmethod da subclasse"

# ‚≠ê ARMA√á√ÉO COMUM: Confundir staticmethod com classmethod
class CalculadoraErrada:
    valor_padrao = 10

    @staticmethod
    def calcular_errado(x):
        # ‚ö†Ô∏è ERRO: N√£o pode acessar valor_padrao!
        # return x + CalculadoraErrada.valor_padrao  # Funciona, mas √© gambiarra
        return x + 10  # Correto para staticmethod

    @classmethod
    def calcular_correto(cls, x):
        # ‚úÖ CORRETO: Pode acessar cls.valor_padrao
        return x + cls.valor_padrao

class CalculadoraEspecial(CalculadoraErrada):
    valor_padrao = 20

# Teste
print("\n" + "=" * 50)
print("CASOS ESPECIAIS E ARMA√á√ïES")
print("=" * 50)

# 1. Heran√ßa com classmethod
print("1. Heran√ßa com classmethod:")
obj_base = CasosEspeciais()
obj_especial = SubclasseEspecial()

print(f"   CasosEspeciais.metodo_b(): {CasosEspeciais.metodo_b()}")
print(f"   SubclasseEspecial.metodo_b(): {SubclasseEspecial.metodo_b()}")

# 2. Factory method com heran√ßa
print("\n2. Factory method:")
fabrica1 = CasosEspeciais.criar_tipo("normal")
fabrica2 = CasosEspeciais.criar_tipo("especial", "parametro_extra")
print(f"   Tipo normal: {type(fabrica1).__name__}")
print(f"   Tipo especial: {type(fabrica2).__name__}")

# 3. Problema com staticmethod vs classmethod
print("\n3. Staticmethod vs Classmethod na heran√ßa:")
calc_base = CalculadoraErrada()
calc_especial = CalculadoraEspecial()

print(f"   Errada (staticmethod): {calc_base.calcular_errado(5)}")
print(f"   Errada na subclasse: {calc_especial.calcular_errado(5)} ‚Üê Mesmo resultado!")

print(f"\n   Correta (classmethod): {calc_base.calcular_correto(5)}")
print(f"   Correta na subclasse: {calc_especial.calcular_correto(5)} ‚Üê Diferente! ‚úÖ")
üéØ RESUMO FINAL - QUANDO USAR CADA UM:
Use @classmethod quando:
Precisa acessar ou modificar estado da CLASSE

Factory methods (criar inst√¢ncias com configura√ß√µes diferentes)

M√©todos alternativos de constru√ß√£o (from_json, from_string, etc.)

Configura√ß√µes que afetam todas as inst√¢ncias

Heran√ßa importante (o m√©todo deve funcionar nas subclasses)

Use @staticmethod quando:
Fun√ß√£o utilit√°ria que n√£o precisa de self nem cls

Fun√ß√£o de helper que faz sentido estar dentro da classe

Fun√ß√µes puras (n√£o tem efeitos colaterais)

Organiza√ß√£o (agrupar fun√ß√µes relacionadas)

Quando o m√©todo n√£o depende do estado da classe nem da inst√¢ncia

Use m√©todo de inst√¢ncia (padr√£o) quando:
Precisa acessar self (atributos da inst√¢ncia)

Modificar estado do objeto

M√©todos que operam sobre dados espec√≠ficos da inst√¢ncia

üí° REGRA PR√ÅTICA:
python
class MinhaClasse:

    def metodo_normal(self):
        """Quando precisa de dados do OBJETO"""
        return self.dados

    @classmethod
    def metodo_classe(cls):
        """Quando precisa de dados da CLASSE"""
        return cls.configuracao

    @staticmethod
    def metodo_estatico():
        """Quando N√ÉO precisa de OBJETO nem CLASSE"""
        return "Sou independente"
Dica: Se voc√™ est√° pensando "preciso fazer uma fun√ß√£o que...", provavelmente √© um @staticmethod. Se est√° pensando "preciso criar objetos de forma diferente...", provavelmente √© um @classmethod.